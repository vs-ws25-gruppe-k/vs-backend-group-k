spring.application.name=ToDo-App

# Import environment variables from .env file, if it exists
spring.config.import=optional:file:.env[.properties]

# Server configuration
server.port=${PORT:8080}
server.forward-headers-strategy=framework

# Active profile
spring.profiles.active=${SPRING_PROFILES_ACTIVE:prod}

# Production config
spring.datasource.url=${DATABASE_URL:jdbc:postgresql://localhost:5432/tododb}
spring.datasource.username=${POSTGRES_USER:todouser}
spring.datasource.password=${POSTGRES_PASSWORD:secret}
spring.session.store-type=jdbc
spring.session.jdbc.initialize-schema=always

# JPA Configuration
spring.jpa.hibernate.ddl-auto=${JPA_HIBERNATE_DDL_AUTO:update}
spring.jpa.properties.hibernate.format_sql = true
spring.datasource.hikari.auto-commit=true
spring.jpa.properties.hibernate.jdbc.batch_size=1000
spring.sql.init.mode=always
spring.jpa.open-in-view=false
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB
spring.main.allow-bean-definition-overriding=true

# Docker Compose integration for production
spring.docker.compose.enabled=true
spring.docker.compose.file=docker-compose.yaml
spring.docker.compose.lifecycle-management=start_only

# Security configuration for spring actuator
spring.security.user.name=${SPRING_SECURITY_USER_NAME}
spring.security.user.password=${SPRING_SECURITY_USER_PASSWORD}

# Naming strategy (camelCase for JSON, might have to be adjusted to LOWER_CAMEL_CASE depending on frontend)
spring.jackson.property-naming-strategy=SNAKE_CASE
